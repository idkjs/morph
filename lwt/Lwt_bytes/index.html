<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_bytes (lwt.Lwt_bytes)</title><link rel="stylesheet" href="../../odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">lwt</a> &#x00BB; Lwt_bytes</nav><h1>Module <code>Lwt_bytes</code></h1><p>Byte arrays</p><nav class="toc"><ul><li><a href="#access">Access</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#copying">Copying</a></li><li><a href="#filling">Filling</a></li><li><a href="#ios">IOs</a></li><li><a href="#memory-mapped-files">Memory mapped files</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span><span>(char, Stdlib.Bigarray.int8_unsigned_elt, Stdlib.Bigarray.c_layout)</span> Stdlib.Bigarray.Array1.t</span></code></dt><dd><p>Type of array of bytes.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Creates a new byte array of the given size.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the length of the given byte array.</p></dd></dl><section><header><h3 id="access"><a href="#access" class="anchor"></a>Access</h3></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>get buffer offset</code> returns the byte at offset <code>offset</code> in <code>buffer</code>.</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>get buffer offset value</code> changes the value of the byte at offset <code>offset</code> in <code>buffer</code> to <code>value</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_get"><a href="#val-unsafe_get" class="anchor"></a><code><span class="keyword">val</span> unsafe_get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p>Same as <a href="index.html#val-get"><code>get</code></a> but without bounds checking.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_set"><a href="#val-unsafe_set" class="anchor"></a><code><span class="keyword">val</span> unsafe_set : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-set"><code>set</code></a> but without bounds checking.</p></dd></dl></section><section><header><h3 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h3></header><dl><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : bytes <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_bytes buf</code> returns a newly allocated byte array with the same contents as <code>buf</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_string buf</code> returns a newly allocated byte array with the same contents as <code>buf</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>to_bytes buf</code> returns newly allocated bytes with the same contents as <code>buf</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string buf</code> returns a newly allocated string with the same contents as <code>buf</code>.</p></dd></dl></section><section><header><h3 id="copying"><a href="#copying" class="anchor"></a>Copying</h3></header><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit buf1 ofs1 buf2 ofs2 len</code> copies <code>len</code> bytes from <code>buf1</code> starting at offset <code>ofs1</code> to <code>buf2</code> starting at offset <code>ofs2</code>.</p></dd></dl><dl><dt class="spec value" id="val-blit_from_bytes"><a href="#val-blit_from_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_from_bytes : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-blit"><code>blit</code></a> but the first buffer is a string instead of a byte array.</p></dd></dl><dl><dt class="spec value" id="val-blit_to_bytes"><a href="#val-blit_to_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_to_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-blit"><code>blit</code></a> but the second buffer is a string instead of a byte array.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_blit"><a href="#val-unsafe_blit" class="anchor"></a><code><span class="keyword">val</span> unsafe_blit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-blit"><code>blit</code></a> but without bound checking.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_blit_from_bytes"><a href="#val-unsafe_blit_from_bytes" class="anchor"></a><code><span class="keyword">val</span> unsafe_blit_from_bytes : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-blit_from_bytes"><code>Lwt_bytes.blit_from_bytes</code></a> but without bounds checking.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_blit_to_bytes"><a href="#val-unsafe_blit_to_bytes" class="anchor"></a><code><span class="keyword">val</span> unsafe_blit_to_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-blit_to_bytes"><code>Lwt_bytes.blit_to_bytes</code></a> but without bounds checking.</p></dd></dl><dl><dt class="spec value" id="val-proxy"><a href="#val-proxy" class="anchor"></a><code><span class="keyword">val</span> proxy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>proxy buffer offset length</code> creates a ``proxy''. The returned byte array share the data of <code>buffer</code> but with different bounds.</p></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val</span> extract : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>extract buffer offset length</code> creates a new byte array of length <code>length</code> and copy the <code>length</code> bytes of <code>buffer</code> at <code>offset</code> into it.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>copy buffer</code> creates a copy of the given byte array.</p></dd></dl></section><section><header><h3 id="filling"><a href="#filling" class="anchor"></a>Filling</h3></header><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill buffer offset length value</code> puts <code>value</code> in all <code>length</code> bytes of <code>buffer</code> starting at offset <code>offset</code>.</p></dd></dl><dl><dt class="spec external" id="val-unsafe_fill"><a href="#val-unsafe_fill" class="anchor"></a><code><span class="keyword">val</span> unsafe_fill : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-fill"><code>fill</code></a> but without bounds checking.</p></dd></dl></section><section><header><h3 id="ios"><a href="#ios" class="anchor"></a>IOs</h3></header><aside><p>The following functions behave similarly to the ones in <a href="../Lwt_unix/index.html"><code>Lwt_unix</code></a>, except they use byte arrays instead of strings, and they never perform extra copies of the data.</p></aside><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dt class="spec value" id="val-recv"><a href="#val-recv" class="anchor"></a><code><span class="keyword">val</span> recv : <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Unix.msg_flag list</span> <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Not implemented on Windows.</p></dd></dl><dl><dt class="spec value" id="val-send"><a href="#val-send" class="anchor"></a><code><span class="keyword">val</span> send : <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Unix.msg_flag list</span> <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Not implemented on Windows.</p></dd></dl><dl><dt class="spec value" id="val-recvfrom"><a href="#val-recvfrom" class="anchor"></a><code><span class="keyword">val</span> recvfrom : <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Unix.msg_flag list</span> <span>&#45;&gt;</span> <span><span>(int * Unix.sockaddr)</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Not implemented on Windows.</p></dd></dl><dl><dt class="spec value" id="val-sendto"><a href="#val-sendto" class="anchor"></a><code><span class="keyword">val</span> sendto : <a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Unix.msg_flag list</span> <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Not implemented on Windows.</p></dd></dl><dl><dt class="spec type" id="type-io_vector"><a href="#type-io_vector" class="anchor"></a><code><span class="keyword">type</span> io_vector</code><code> = </code><code>{</code><table class="record"><tr id="type-io_vector.iov_buffer" class="anchored"><td class="def field"><a href="#type-io_vector.iov_buffer" class="anchor"></a><code>iov_buffer : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-io_vector.iov_offset" class="anchored"><td class="def field"><a href="#type-io_vector.iov_offset" class="anchor"></a><code>iov_offset : int;</code></td></tr><tr id="type-io_vector.iov_length" class="anchored"><td class="def field"><a href="#type-io_vector.iov_length" class="anchor"></a><code>iov_length : int;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-io_vector"><a href="#val-io_vector" class="anchor"></a><code><span class="keyword">val</span> io_vector : <span>buffer:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>offset:int</span> <span>&#45;&gt;</span> <span>length:int</span> <span>&#45;&gt;</span> <a href="index.html#type-io_vector">io_vector</a></code></dt><dt class="spec value" id="val-recv_msg"><a href="#val-recv_msg" class="anchor"></a><code><span class="keyword">val</span> recv_msg : <span>socket:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a></span> <span>&#45;&gt;</span> <span>io_vectors:<span><a href="index.html#type-io_vector">io_vector</a> list</span></span> <span>&#45;&gt;</span> <span><span>(int * <span>Unix.file_descr list</span>)</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Not implemented on Windows.</p><dl><dt>deprecated</dt><dd><p>Use <a href="../Lwt_unix/Versioned/index.html#val-recv_msg_2"><code>Lwt_unix.Versioned.recv_msg_2</code></a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-send_msg"><a href="#val-send_msg" class="anchor"></a><code><span class="keyword">val</span> send_msg : <span>socket:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a></span> <span>&#45;&gt;</span> <span>io_vectors:<span><a href="index.html#type-io_vector">io_vector</a> list</span></span> <span>&#45;&gt;</span> <span>fds:<span>Unix.file_descr list</span></span> <span>&#45;&gt;</span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p>Not implemented on Windows.</p><dl><dt>deprecated</dt><dd><p>Use <a href="../Lwt_unix/Versioned/index.html#val-send_msg_2"><code>Lwt_unix.Versioned.send_msg_2</code></a>.</p></dd></dl></dd></dl></section><section><header><h3 id="memory-mapped-files"><a href="#memory-mapped-files" class="anchor"></a>Memory mapped files</h3></header><dl><dt class="spec value" id="val-map_file"><a href="#val-map_file" class="anchor"></a><code><span class="keyword">val</span> map_file : <span>fd:Unix.file_descr</span> <span>&#45;&gt;</span> <span>?&#8288;pos:int64</span> <span>&#45;&gt;</span> <span>shared:bool</span> <span>&#45;&gt;</span> <span>?&#8288;size:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map_file ~fd ?pos ~shared ?size ()</code> maps the file descriptor <code>fd</code> to an array of bytes.</p></dd></dl><dl><dt class="spec external" id="val-mapped"><a href="#val-mapped" class="anchor"></a><code><span class="keyword">val</span> mapped : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mapped buffer</code> returns <code>true</code> iff <code>buffer</code> is a memory mapped file.</p></dd></dl><dl><dt class="spec type" id="type-advice"><a href="#type-advice" class="anchor"></a><code><span class="keyword">type</span> advice</code><code> = </code><table class="variant"><tr id="type-advice.MADV_NORMAL" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_NORMAL" class="anchor"></a><code>| </code><code><span class="constructor">MADV_NORMAL</span></code></td></tr><tr id="type-advice.MADV_RANDOM" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_RANDOM" class="anchor"></a><code>| </code><code><span class="constructor">MADV_RANDOM</span></code></td></tr><tr id="type-advice.MADV_SEQUENTIAL" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_SEQUENTIAL" class="anchor"></a><code>| </code><code><span class="constructor">MADV_SEQUENTIAL</span></code></td></tr><tr id="type-advice.MADV_WILLNEED" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_WILLNEED" class="anchor"></a><code>| </code><code><span class="constructor">MADV_WILLNEED</span></code></td></tr><tr id="type-advice.MADV_DONTNEED" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_DONTNEED" class="anchor"></a><code>| </code><code><span class="constructor">MADV_DONTNEED</span></code></td></tr><tr id="type-advice.MADV_MERGEABLE" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_MERGEABLE" class="anchor"></a><code>| </code><code><span class="constructor">MADV_MERGEABLE</span></code></td></tr><tr id="type-advice.MADV_UNMERGEABLE" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_UNMERGEABLE" class="anchor"></a><code>| </code><code><span class="constructor">MADV_UNMERGEABLE</span></code></td></tr><tr id="type-advice.MADV_HUGEPAGE" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_HUGEPAGE" class="anchor"></a><code>| </code><code><span class="constructor">MADV_HUGEPAGE</span></code></td></tr><tr id="type-advice.MADV_NOHUGEPAGE" class="anchored"><td class="def constructor"><a href="#type-advice.MADV_NOHUGEPAGE" class="anchor"></a><code>| </code><code><span class="constructor">MADV_NOHUGEPAGE</span></code></td></tr></table></dt><dd><p>Type of advise that can be sent to the kernel by the program. See the manual madvise(2) for a description of each.</p></dd></dl><dl><dt class="spec value" id="val-madvise"><a href="#val-madvise" class="anchor"></a><code><span class="keyword">val</span> madvise : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-advice">advice</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>madvise buffer pos len advice</code> advises the kernel how the program will use the memory mapped file between <code>pos</code> and <code>pos + len</code>.</p><p>This call is not available on windows.</p></dd></dl><dl><dt class="spec value" id="val-page_size"><a href="#val-page_size" class="anchor"></a><code><span class="keyword">val</span> page_size : int</code></dt><dd><p>Size of pages.</p></dd></dl><dl><dt class="spec value" id="val-mincore"><a href="#val-mincore" class="anchor"></a><code><span class="keyword">val</span> mincore : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>bool array</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>mincore buffer offset states</code> tests whether the given pages are in the system memory (the RAM). The <code>offset</code> argument must be a multiple of <a href="index.html#val-page_size"><code>page_size</code></a>. <code>states</code> is used to store the result; each cases is <code>true</code> if the corresponding page is in RAM and <code>false</code> otherwise.</p><p>This call is not available on windows and cygwin.</p></dd></dl><dl><dt class="spec value" id="val-wait_mincore"><a href="#val-wait_mincore" class="anchor"></a><code><span class="keyword">val</span> wait_mincore : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></code></dt><dd><p><code>wait_mincore buffer offset</code> waits until the page containing the byte at offset <code>offset</code> is in RAM.</p><p>This functions is not available on windows and cygwin.</p></dd></dl></section></div></body></html>
